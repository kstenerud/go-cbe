// This program is used to populate the whitespace and control chars section of
// `charProperties` in 	github.com/kstenerud/go-concise-encoding/internal/common/unicode.go
package main

import (
	"encoding/xml"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"sort"
	"strconv"
)

func main() {
	if len(os.Args) != 2 {
		printUsage(os.Stderr)
		os.Exit(1)
	}

	path := os.Args[1]
	chars, err := loadDB(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading %v: %v\n", path, err)
		os.Exit(1)
	}

	lines := getWhitespaceLines(chars)
	lines = append(lines, getControlCharLines(chars)...)
	sort.Strings(lines)

	fmt.Printf("package common\n\n")
	fmt.Printf("// Generated by github.com/kstenerud/go-concise-encoding/build-tools/unicode-gen\n")
	fmt.Printf("// DO NOT EDIT\n")
	fmt.Printf("func init() {\n")
	for _, line := range lines {
		fmt.Println(line)
	}
	fmt.Printf("}\n")
}

func loadDB(path string) (chars CharSet, err error) {
	document, err := ioutil.ReadFile(path)
	if err != nil {
		return
	}

	var dbWrapper DBWrapper
	if err = xml.Unmarshal(document, &dbWrapper); err != nil {
		return
	}

	chars = make(CharSet, 0, len(dbWrapper.DB.Chars))
	for _, char := range dbWrapper.DB.Chars {
		if char.Validate() {
			chars = append(chars, char)
		}
	}
	return
}

func getWhitespaceLines(chars CharSet) []string {
	return chars.GetPropertiesLinesIfCriteria("CharIsWhitespace", func(char *Char) bool {
		switch char.Codepoint {
		case '\r', '\n', '\t':
			return true
		case 0x1680:
			return false
		}
		if char.Codepoint < 0x20 {
			return false
		}
		return char.Category == "Zs" || char.Category == "Zl" || char.Category == "Zp"
	})
}

func getControlCharLines(chars CharSet) []string {
	return chars.GetPropertiesLinesIfCriteria("CharIsControl", func(char *Char) bool {
		return char.Category == "Cc" || char.Category == "Cf"
	})
}

func printUsage(writer io.Writer) {
	fmt.Fprintf(writer, "Usage: %v /path/to/ucd.all.flat.xml\n", os.Args[0])
	fmt.Fprintln(writer, "Requires ucd.all.flat.xml from https://www.unicode.org/Public/UCD/latest/ucdxml/ucd.all.flat.zip")
}

type CharSet []*Char

func (_this CharSet) GetPropertiesLinesIfCriteria(properties string, criteria func(*Char) bool) (lines []string) {
	for _, char := range _this {
		if criteria(char) {
			lines = append(lines, char.GetPropertiesLine(properties))
		}
	}
	return
}

type DBWrapper struct {
	XMLName xml.Name   `xml:"ucd"`
	DB      *UnicodeDB `xml:"repertoire"`
}

type UnicodeDB struct {
	XMLName xml.Name `xml:"repertoire"`
	Chars   []*Char  `xml:"char"`
}

func (_this *UnicodeDB) PerformAction(criteria func(*Char) bool, action func(*Char)) {
	for _, char := range _this.Chars {
		if criteria(char) {
			action(char)
		}
	}
}

type Char struct {
	XMLName      xml.Name `xml:"char"`
	CodepointStr string   `xml:"cp,attr"`
	Category     string   `xml:"gc,attr"`
	BidiCategory string   `xml:"bc,attr"`
	Codepoint    int
}

func (_this *Char) Validate() bool {
	codepoint, err := strconv.ParseInt(_this.CodepointStr, 16, 32)
	if err != nil {
		return false
	}
	_this.Codepoint = int(codepoint)
	return true
}

func (_this *Char) GetPropertiesLine(properties string) string {
	return fmt.Sprintf("\tcharProperties[0x%05x] = %v", _this.Codepoint, properties)
}
